#lang racket
(require redex)

(define-language tglc
  (e ::= x v (λ (f x) e) (e e) (+ e e) (ref e) (! e) (:= e e))
  (x f ::= variable-not-otherwise-mentioned)
  (a ::= integer) ;address
  (v ::= a integer) 
  (E ::= hole (E e) (v E) (+ E e) (+ v E) (ref E) (! E) (:= E e))
  #:binding-forms
  (λ (f x) e #:refers-to x))
(default-language tglc)

(module+ test
  (test-equal (redex-match? tglc e (term y)) #t)
  (test-equal (redex-match? tglc e (term 123)) #t)
  (test-equal (redex-match? tglc e (term (λ (coolfunction y) y))) #t)
  (test-equal (redex-match? tglc e (term (x x))) #t)
  (test-equal (redex-match? tglc e (term (ref x)) #t))
  (test-equal (redex-match? tglc e (term (! x))) #t)
  (test-equal (redex-match? tglc e (term (:= x y))) #t)
  (test-equal (redex-match? tglc e (term (+ 2 1))) #t))

(module+ test
  (test-results))